// ############################################################################
// ### Author: Andrew Photinakis                                            ###
// ### File: PrimeExtension.cs                                              ###
// ### Description: Provides extension methods for BigInteger to            ###
// ### handle prime number generation using various algorithms,             ###
// ### including Miller-Rabin primality test and naive prime generation.    ###
// ### Date: 12/03/2024                                                     ###
// ############################################################################
using System.Numerics;

namespace ExtensionMethod
{
    /// <summary>
    /// Provides extension methods for BigInteger to handle prime number generation.
    /// </summary>
    public static class PrimeExtension
    {

        private static SecureRandomNamespace.SecureRandom secureRandom = new SecureRandomNamespace.SecureRandom();
        private static readonly object lockObj = new object();

        /// <summary>
        /// List to store auto-generated prime numbers.
        /// </summary>
        public static List<BigInteger> autoGeneratedPrimes = new List<BigInteger>();

        /// <summary>
        /// Checks if a BigInteger is probably prime using the Miller-Rabin primality test.
        /// </summary>
        /// <param name="n">The BigInteger to test for primality.</param>
        /// <param name="k">The number of iterations for the Miller-Rabin test (default is 10).</param>
        /// <returns>True if the number is probably prime; otherwise, false.</returns>
        static bool IsProbablyPrime(this BigInteger n, int k = 10)
        {
            if (n <= 3)
            {
                return n == 2;
            }
            BigInteger d = n - 1;
            int r = 0;
            while (d % 2 == 0)
            {
                d /= 2;
                r++;
            }
            for (int i = 0; i < k; i++)
            {
                BigInteger a = GetRandomA(n);
                BigInteger x = BigInteger.ModPow(a, d, n);
                if (x == 1 || x == n - 1)
                {
                    continue;
                }
                for (int j = 0; j < r - 1; j++)
                {
                    x = BigInteger.ModPow(x, 2, n);
                    if (x == n - 1)
                    {
                        continue;
                    }
                }
                return false;
            }
            return true;
        }

        /// <summary>
        /// Generates a random BigInteger within the range [2, n-2].
        /// </summary>
        /// <param name="n">The upper bound for the generated number (exclusive).</param>
        /// <returns>A random BigInteger within the specified range.</returns>
        public static BigInteger GetRandomA(BigInteger n)
        {
            while (true)
            {
                byte[] randomBytes = new byte[n.ToByteArray().Length];
                secureRandom.NextBytes(randomBytes);
                BigInteger randomBigInteger = new BigInteger(randomBytes);
                if (randomBigInteger >= 2 && randomBigInteger < n - 2)
                {
                    return randomBigInteger;
                }
            }
        }

        /// <summary>
        /// Generates prime numbers using a naive algorithm.
        /// </summary>
        /// <param name="n">The number of prime numbers to generate.</param>
        public static void GeneratePrimesNaive(int n)
        {
            autoGeneratedPrimes.Add(2);
            int nextPrime = 3;

            while (autoGeneratedPrimes.Count < n)
            {
                int sqrt = (int)Math.Sqrt(nextPrime);
                bool isPrime = true;
                for (int i = 0; (int)autoGeneratedPrimes[i] <= sqrt; i++)
                {
                    if (nextPrime % autoGeneratedPrimes[i] == 0)
                    {
                        isPrime = false;
                        break;
                    }
                }
                if (isPrime)
                {
                    autoGeneratedPrimes.Add(nextPrime);
                }
                nextPrime += 2;
            }
        }

        /// <summary>
        /// Checks if a BigInteger is prime by testing divisibility against a list of known primes.
        /// </summary>
        /// <param name="candidate">The BigInteger to test for primality.</param>
        /// <returns>True if the number is prime; otherwise, false.</returns>
        public static bool CheckPrime(BigInteger candidate)
        {
            foreach (BigInteger prime in autoGeneratedPrimes)
            {
                if (BigInteger.Compare(candidate, prime) < 0)
                {
                    return true;
                }
                if (candidate % prime == 0)
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Generates a prime number with the specified number of bits and Miller-Rabin test iterations.
        /// </summary>
        /// <param name="bits">The number of bits for the generated prime.</param>
        /// <param name="k">The number of iterations for the Miller-Rabin test.</param>
        /// <returns>A prime BigInteger with the specified number of bits.</returns>
        public static BigInteger GeneratePrime(int bits, int k)
        {
            BigInteger primeCandidate = BigInteger.Zero;
            var cts = new CancellationTokenSource();
            int byteLength = bits / 8;
            Parallel.For(0, Int32.MaxValue, (i, state) =>
            {
                if (cts.Token.IsCancellationRequested)
                {
                    state.Stop();
                    return;
                }

                BigInteger candidate;
                lock (lockObj)
                {
                    if (state.IsStopped)
                    {
                        return;
                    }
                    byte[] randomBytes = new byte[byteLength];
                    secureRandom.NextBytes(randomBytes);
                    candidate = BigInteger.Abs(new BigInteger(randomBytes));
                }

                if (!CheckPrime(candidate))
                {
                    return;
                }

                if (candidate.IsProbablyPrime())
                {
                    primeCandidate = candidate;
                    cts.Cancel();
                    state.Stop();
                }
                else
                {
                }
            });
            cts.Dispose();
            return primeCandidate;
        }
    }
}